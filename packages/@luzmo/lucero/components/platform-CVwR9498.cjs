/*! * Lucero - The design system for Luzmo.
 * 
 * Copyright © 2025 Luzmo
 * All rights reserved.
 * Lucero (“Luzmo Design System”) must be used according to the Luzmo Terms of Service.
 * This license allows users with a current active Luzmo account to use Lucero.
 * This license terminates automatically if a user no longer has an active Luzmo account.
 * Please view the Luzmo Terms of Service at: https://www.luzmo.com/information-pages/terms-of-use.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * */
"use strict";const u=require("./sized-mixin-BMc51ayV.cjs");/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const v={ATTRIBUTE:1,CHILD:2},w=i=>(...e)=>({_$litDirective$:i,values:e});class F{constructor(e){}get _$AU(){return this._$AM._$AU}_$AT(e,t,o){this._$Ct=e,this._$AM=t,this._$Ci=o}_$AS(e,t){return this.update(e,t)}update(e,t){return this.render(...t)}}let d=!0;try{document.body.querySelector(":focus-visible")}catch{d=!1,Promise.resolve().then(()=>_)}const c=i=>{var e,t;const o=n=>{if(n.shadowRoot==null||Object.hasOwn(n.dataset,"jsFocusVisible"))return()=>{};if(self.applyFocusVisiblePolyfill)self.applyFocusVisiblePolyfill(n.shadowRoot),n.manageAutoFocus&&n.manageAutoFocus();else{const m=()=>{self.applyFocusVisiblePolyfill&&n.shadowRoot&&self.applyFocusVisiblePolyfill(n.shadowRoot),n.manageAutoFocus&&n.manageAutoFocus()};return self.addEventListener("focus-visible-polyfill-ready",m,{once:!0}),()=>{self.removeEventListener("focus-visible-polyfill-ready",m)}}return()=>{}},s=Symbol("endPolyfillCoordination");class a extends(t=i,e=s,t){constructor(){super(...arguments),this[e]=null}connectedCallback(){super.connectedCallback&&super.connectedCallback(),d||requestAnimationFrame(()=>{this[s]==null&&(this[s]=o(this))})}disconnectedCallback(){super.disconnectedCallback&&super.disconnectedCallback(),d||requestAnimationFrame(()=>{this[s]!=null&&(this[s](),this[s]=null)})}}return a},_=Object.freeze(Object.defineProperty({__proto__:null,FocusVisiblePolyfillMixin:c},Symbol.toStringTag,{value:"Module"}));var C=Object.defineProperty,P=Object.getOwnPropertyDescriptor,f=(i,e,t,o)=>{for(var s=o>1?void 0:o?P(e,t):e,a=i.length-1,n;a>=0;a--)(n=i[a])&&(s=(o?n(e,t,s):n(s))||s);return o&&s&&C(e,t,s),s};function p(){return new Promise(i=>requestAnimationFrame(()=>i()))}class r extends c(u.LuzmoElement){constructor(){super(...arguments),this.disabled=!1,this.autofocus=!1,this._tabIndex=0,this.manipulatingTabindex=!1,this.autofocusReady=Promise.resolve()}get tabIndex(){if(this.focusElement===this){const t=this.hasAttribute("tabindex")?Number(this.getAttribute("tabindex")):Number.NaN;return Number.isNaN(t)?-1:t}const e=Number.parseFloat(this.hasAttribute("tabindex")&&this.getAttribute("tabindex")||"0");return this.disabled||e<0?-1:this.focusElement?this._tabIndex:e}set tabIndex(e){var t;if(this.manipulatingTabindex){this.manipulatingTabindex=!1;return}if(this.focusElement===this){if(this.disabled)this._tabIndex=e;else if(e!==this._tabIndex){this._tabIndex=e;const o=""+e;this.manipulatingTabindex=!0,this.setAttribute("tabindex",o)}return}if(e===-1?this.addEventListener("pointerdown",this.onPointerdownManagementOfTabIndex):(this.manipulatingTabindex=!0,this.removeEventListener("pointerdown",this.onPointerdownManagementOfTabIndex)),e===-1||this.disabled){if(this.manipulatingTabindex=!0,this.setAttribute("tabindex","-1"),this.removeAttribute("focusable"),this.selfManageFocusElement)return;e===-1?(t=this.focusElement)==null||t.removeAttribute("tabindex"):(this._tabIndex=e,this.manageFocusElementTabindex(e));return}this.setAttribute("focusable",""),this.hasAttribute("tabindex")?this.removeAttribute("tabindex"):this.manipulatingTabindex=!1,this._tabIndex=e,this.manageFocusElementTabindex(e)}onPointerdownManagementOfTabIndex(){this.tabIndex===-1&&setTimeout(()=>{this.tabIndex=0,this.focus({preventScroll:!0}),this.tabIndex=-1})}async manageFocusElementTabindex(e){this.focusElement||await this.updateComplete,e===null?this.focusElement.removeAttribute("tabindex"):this.focusElement!==this&&(this.focusElement.tabIndex=e)}get focusElement(){throw new Error("Must implement focusElement getter!")}get selfManageFocusElement(){return!1}focus(e){this.disabled||!this.focusElement||(this.focusElement===this?Reflect.apply(HTMLElement.prototype.focus,this,[e]):this.focusElement.focus(e))}blur(){const e=this.focusElement||this;e===this?HTMLElement.prototype.blur.apply(this):e.blur()}click(){if(this.disabled)return;const e=this.focusElement||this;e===this?HTMLElement.prototype.click.apply(this):e.click()}manageAutoFocus(){this.autofocus&&(this.dispatchEvent(new KeyboardEvent("keydown",{code:"Tab"})),this.focusElement.focus())}firstUpdated(e){super.firstUpdated(e),(!this.hasAttribute("tabindex")||this.getAttribute("tabindex")!=="-1")&&this.setAttribute("focusable","")}update(e){e.has("disabled")&&this.handleDisabledChanged(this.disabled,e.get("disabled")),super.update(e)}updated(e){super.updated(e),e.has("disabled")&&this.disabled&&this.blur()}async handleDisabledChanged(e,t){const o=()=>this.focusElement!==this&&this.focusElement.disabled!==void 0;e?(this.manipulatingTabindex=!0,this.setAttribute("tabindex","-1"),await this.updateComplete,o()?this.focusElement.disabled=!0:this.setAttribute("aria-disabled","true")):t&&(this.manipulatingTabindex=!0,this.focusElement===this?this.setAttribute("tabindex",""+this._tabIndex):this.removeAttribute("tabindex"),await this.updateComplete,o()?this.focusElement.disabled=!1:this.removeAttribute("aria-disabled"))}async getUpdateComplete(){const e=await super.getUpdateComplete();return await this.autofocusReady,e}connectedCallback(){super.connectedCallback(),this.autofocus&&(this.autofocusReady=new Promise(async e=>{await p(),await p(),e()}),this.updateComplete.then(()=>{this.manageAutoFocus()}))}}f([u.n({type:Boolean,reflect:!0})],r.prototype,"disabled",2);f([u.n({type:Boolean})],r.prototype,"autofocus",2);f([u.n({type:Number})],r.prototype,"tabIndex",1);function l(i){return typeof window<"u"&&window.navigator!=null?i.test(window.navigator.userAgent):!1}function h(i){return typeof window<"u"&&window.navigator!=null?i.test(window.navigator.platform):!1}function b(){return h(/^Mac/)}function y(){return h(/^iPhone/)}function x(){return h(/^iPad/)||b()&&navigator.maxTouchPoints>1}function A(){return y()||x()}function T(){return b()||A()}function g(){return l(/Chrome/)}function M(){return l(/AppleWebKit/)&&!g()}function E(){return l(/Seamonkey/)}function I(){return l(/Firefox/)&&!E()}function O(){return l(/Android/)}exports.FocusVisiblePolyfillMixin=c;exports.Focusable=r;exports.e=w;exports.i=F;exports.isAndroid=O;exports.isAppleDevice=T;exports.isChrome=g;exports.isFirefox=I;exports.isIOS=A;exports.isIPad=x;exports.isIPhone=y;exports.isMac=b;exports.isSeamonkey=E;exports.isWebKit=M;exports.t=v;
